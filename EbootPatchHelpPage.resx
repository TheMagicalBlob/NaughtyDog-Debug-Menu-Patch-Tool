<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Question3Btn.Text" xml:space="preserve">
    <value>
Because Depending On The Game, There May
Either Be A Large Amount Of Skipped Or 
Uncalled Code That Can Be Restored With
Varrying Levels Of Effort

Or There May Only Be Small Things Leftover
Which I Just Add To Existing Submenus For
The "Custom Debug".

However- I'm not Gonna Sit Around And
Make These Patches For Every Version Of
Every Game. For These, The Button's Disabled</value>
  </data>
  <data name="Question2Btn.Text" xml:space="preserve">
    <value>
- The First Way Is With The Official PS4 SDK Tools,
  Which I Can Not Include In My Projects Due To
  Them Being Copyrighted Sony PS4 SDK Tools.

  Use The PkgCreationPage To Build A New
  .pkg Once You've Got The FakePKGTools
  Downloaded, And Have Made A .gp4
  

- The Second Way Is With The Patch Builder
  App From ModdedWarfrare, Which You
  Can Easily Find With A Quick Google
  Or Even Youtube Search
</value>
  </data>
  <data name="Question1Btn.Text" xml:space="preserve">
    <value>
- App Dumper: Dump The App Via The
   Homebrew Store Or Vtx Dumper 1.8
   Payload By Running The Game,
   Then Sending The Dumper Payload To
   The PS4 With An Ext HDD/SSD Connected.

- fPKG/.pkg: Open orbis-pub-chk And Import The .pkg
  You Want To Extract By Dragging It, Or With The
  "Add Image" Button. Select The eboot.bin
  And Choose An Output Directory, Then Extract
  (fpkg Password's 32 Zeros)</value>
  </data>
  <data name="DefaultQuestionBtn.Text" xml:space="preserve">
    <value>                                     [General Info]

- Default Debug: Turns The Debug Mode On
   Without Any Other Changes

- Restored Debug: Load Some Hidden Menus That Don't Normally Load While Trying Not To Change Anything About Them

- Custom Debug: Customized Menu, Some Useless Things May Be Deleted, Other Things Changed For Convenience

- Disable Debug: Only Disables The Debug Mode, Does Not Undo Any Other Patches Applied

- PC Debug Menu: Limited Support, Use Ilusion's Patches. Idc About PC Games. Laptop Too Weak</value>
  </data>
  <data name="Question0Btn.Text" xml:space="preserve">
    <value>
- FTP: Have Your PC And PS4 On The Same Network,
  And Either Send The FTP Payload To Your PS4,
  Or Enable FTP In GoldHEN's Settings.
  Then, Go To mnt/sandbox/CUSAXXXXX/app0,
  You Game's Executables And Other Files Will Be There.

- App Dumper: Dump The App Via The
  Homebrew Store, Or Vortex Dumper
  1.8 Payload. The Unsigned Eboot Will
  Be In The Dumped Game Data,
  Ready To Be Patched.

- orbis-pub-chk.exe: Extract The .pkg With The
  Hacked PS4 SDK Tool orbis-pub-chk.exe, Then
  Unsign/Decrypt The eboot With Unfself.exe/.py</value>
  </data>
</root>